{"version":3,"file":"main.js","sourceRoot":"","sources":["../src/main.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n\tjoinVoiceChannel,\n\tcreateAudioPlayer,\n\tcreateAudioResource,\n\tentersState,\n\tStreamType,\n\tAudioPlayerStatus,\n\tVoiceConnectionStatus,\n} from '@discordjs/voice';\nimport { GatewayIntentBits } from 'discord-api-types/v9';\nimport { Client, VoiceBasedChannel } from 'discord.js';\nimport { createDiscordJSAdapter } from './adapter';\n\n// eslint-disable-next-line @typescript-eslint/no-var-requires, @typescript-eslint/no-require-imports\nconst { token } = require('../config.json') as { token: string };\n\n/**\n * \tIn this example, we are creating a single audio player that plays to a number of voice channels.\n * The audio player will play a single track.\n */\n\n/**\n * Create the audio player. We will use this for all of our connections.\n */\nconst player = createAudioPlayer();\n\nfunction playSong() {\n\t/**\n\t * Here we are creating an audio resource using a sample song freely available online\n\t * (see https://www.soundhelix.com/audio-examples)\n\t *\n\t * We specify an arbitrary inputType. This means that we aren't too sure what the format of\n\t * the input is, and that we'd like to have this converted into a format we can use. If we\n\t * were using an Ogg or WebM source, then we could change this value. However, for now we\n\t * will leave this as arbitrary.\n\t */\n\tconst resource = createAudioResource('https://cdn.discordapp.com/attachments/700005638184370307/1248132284704620604/Lil-Nas-X-Panini-Official-Video.mp3?ex=66628d45&is=66613bc5&hm=b557dff54233ccefef7d1e948e56b5e1789731b766969733bf84399e3f812bd6&', {\n\t\tinputType: StreamType.Arbitrary,\n\t});\n\n\t/**\n\t * We will now play this to the audio player. By default, the audio player will not play until\n\t * at least one voice connection is subscribed to it, so it is fine to attach our resource to the\n\t * audio player this early.\n\t */\n\tplayer.play(resource);\n\n\t/**\n\t * Here we are using a helper function. It will resolve if the player enters the Playing\n\t * state within 5 seconds, otherwise it will reject with an error.\n\t */\n\treturn entersState(player, AudioPlayerStatus.Playing, 5000);\n}\n\nasync function connectToChannel(channel: VoiceBasedChannel) {\n\t/**\n\t * Here, we try to establish a connection to a voice channel. If we're already connected\n\t * to this voice channel, @discordjs/voice will just return the existing connection for us!\n\t */\n\tconst connection = joinVoiceChannel({\n\t\tchannelId: channel.id,\n\t\tguildId: channel.guild.id,\n\t\tadapterCreator: createDiscordJSAdapter(channel),\n\t});\n\n\t/**\n\t * If we're dealing with a connection that isn't yet Ready, we can set a reasonable\n\t * time limit before giving up. In this example, we give the voice connection 30 seconds\n\t * to enter the ready state before giving up.\n\t */\n\ttry {\n\t\t/**\n\t\t * Allow ourselves 30 seconds to join the voice channel. If we do not join within then,\n\t\t * an error is thrown.\n\t\t */\n\t\tawait entersState(connection, VoiceConnectionStatus.Ready, 30_000);\n\t\t/**\n\t\t * At this point, the voice connection is ready within 30 seconds! This means we can\n\t\t * start playing audio in the voice channel. We return the connection so it can be\n\t\t * used by the caller.\n\t\t */\n\t\treturn connection;\n\t} catch (error) {\n\t\t/**\n\t\t * At this point, the voice connection has not entered the Ready state. We should make\n\t\t * sure to destroy it, and propagate the error by throwing it, so that the calling function\n\t\t * is aware that we failed to connect to the channel.\n\t\t */\n\t\tconnection.destroy();\n\t\tthrow error;\n\t}\n}\n\n/**\n * Main code\n * =========\n * Here we will implement the helper functions that we have defined above.\n */\n\nconst client = new Client({\n\tintents: [GatewayIntentBits.Guilds, GatewayIntentBits.GuildMessages, GatewayIntentBits.GuildVoiceStates],\n});\n\nclient.on('ready', async () => {\n\tconsole.log('Discord.js client is ready!');\n\n\t/**\n\t * Try to get our song ready to play for when the bot joins a voice channel\n\t */\n\ttry {\n\t\tawait playSong();\n\t\tconsole.log('Song is ready to play!');\n\t} catch (error) {\n\t\t/**\n\t\t * The song isn't ready to play for some reason :(\n\t\t */\n\t\tconsole.error(error);\n\t}\n});\n\nclient.on('interactionCreate', async interaction => {\n\tif (!interaction.isCommand()) return;\n\n\tconst { commandName } = interaction;\n\n\tif (commandName === 'ping') {\n\t\tconst channel = interaction.member?.voice.channel;\n\n\t\tif (channel) {\n\t\t\t/**\n\t\t\t * The user is in a voice channel, try to connect.\n\t\t\t */\n\t\t\ttry {\n\t\t\t\tconst connection = await connectToChannel(channel);\n\n\t\t\t\t/**\n\t\t\t\t * We have successfully connected! Now we can subscribe our connection to\n\t\t\t\t * the player. This means that the player will play audio in the user's\n\t\t\t\t * voice channel.\n\t\t\t\t */\n\t\t\t\tconnection.subscribe(player);\n\t\t\t\tawait interaction.reply('Playing now!');\n\t\t\t} catch (error) {\n\t\t\t\t/**\n\t\t\t\t * Unable to connect to the voice channel within 30 seconds :(\n\t\t\t\t */\n\t\t\t\tconsole.error(error);\n\t\t\t}\n\t\t} else {\n\t\t\t/**\n\t\t\t * The user is not in a voice channel.\n\t\t\t */\n\t\t\tvoid interaction.reply('Join a voice channel then try again!');\n\t\t}\n\t}\n});\n\nvoid client.login(token);\n"]}